#
# <copyright>
#  Copyright 2003 Cougaar Software, Inc.
#  under sponsorship of the Defense Advanced Research Projects Agency (DARPA).
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the Cougaar Open Source License as published by
#  DARPA on the Cougaar Open Source Website (www.cougaar.org).
#
#  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS
#  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR
#  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT
#  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT
#  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL
#  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS,
#  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
#  PERFORMANCE OF THE COUGAAR SOFTWARE.
# </copyright>
#

#
# Declarations Section
#

#
# Each of the declarations that follow defines names of policy
# concepts.  These names are used for stating and reasoning about
# policy.  However, in order for these names to be understood by the
# Ultralog enforcers, we need a mapping file that tells how Ultralog
# names are translated into policy names.  
#
# The two exceptions to this scheme are 
#  1. message verbs which are declared in Ontology-EntityInstances.daml and 
#     don't need a mapping file, and
#  2. communities which are declared in Ontology-GroupInstances.daml
#     and don't need a mapping file.
# I haven't moved the verb declarations because it requires a hack
# which I am not yet happy with.  I haven't moved the community
# declarations because they may be going away and I am concerned that
# there might be a performance hit.
#

#
# The policy prefix is prepended to each of the policy names.  It can
# be used - if desired - to arrange that built policies reside in a
# subdirectory.
#
PolicyPrefix=%Allow/


#
# The mapping file for the following KAoS policy names is DamlUserRoleMap.
#

UserRole Administrator
UserRole CAAdministrator
UserRole General
UserRole Guest
UserRole Logistician
UserRole LogisticsViewer
UserRole MonitorManager
UserRole RearPolicyAdministrator
UserRole FwdPolicyAdministrator
UserRole ConusPolicyAdministrator
UserRole TransPolicyAdministrator
UserRole PolicyAdministrator
UserRole UserManager
UserRole SocietyAdmin

#
# The mapping file for the following KAoS policy names is DamlUriMap
#

Servlet AggegatorServlets
Servlet NCAServlets
Servlet SCmrmanagerServlets
Servlet DataGrabberServlet
Servlet CertReqServlet
Servlet CAReadServlet
Servlet CAWriteServlet
Servlet HierarchyServlet
Servlet LogInventoryServlet
Servlet RearPolicyServlet
Servlet FwdPolicyServlet
Servlet ConusPolicyServlet
Servlet TransPolicyServlet
Servlet PolicyServlet
Servlet SocietyAdminServlet
Servlet UserManagerServlets
Servlet OtherServlets


#
# There are three mapping files for these declarations, 
#    RoleAgent        - to get the role from the agent name
#    RoleComponentMap - to get the role from the component name
#    RoleUriMap       - to get the role from the URI
#

PlugInRole OpPlanPlugInRole
PlugInRole PolicyServletRole
PlugInRole OrgActivityAddRole
PlugInRole OrgActivityQueryRole
PlugInRole OrgActivityQueryNoReadRole
PlugInRole OrgActivityChangeRole
PlugInRole OrgActivityRemoveRole
PlugInRole OrgActivityAllRole

#
# The mapping file for these declarations is DamlBlackboardObjectMap.
#

BlackBoardObject BlackboardOpPlanObject
BlackBoardObject SafeRelay
BlackBoardObject OrgActivity

#
# End of Declarations Section
#

#
# Now the Policies follow:
#


#
# Message Passing Policies
#
#     Note: Users of the message passing policy templates need not worry
#           about the policy assumptions because the policy templates
#           satisfy the assumptions. 
#
# Policy Assumptions:
#     1. Positive policies have priority two and can only involve the
#        sender and the receiver and the verb
#     2. Negative policies have priority three and do not involve the verb.
#
#
# Justification:
#    The message enforcer has two enforcement phases and both phases
#     make decisions based on incomplete information.  In order for
#     these enforcers to make valid decisions assumptions 1 & 2 are
#     necessary. 
#

Policy AllowCommunication = [ 
   GenericTemplate
   Priority = 2,
   $Actor.daml#Agent is authorized to perform
   $Action.daml#EncryptedCommunicationAction as long as
    the value of $Action.daml#hasDestination
    is a subset of the set $Actor.daml#Agent
]


#
# Blackboard policies
#

Policy AllowBlackboard = [ 
   GenericTemplate
   Priority = 2,
   $Ultralog/UltralogActor.daml#UltralogPlugins is authorized to perform
   $Ultralog/UltralogAction.daml#BlackBoardAccess as long as
    the value of $Ultralog/UltralogAction.daml#blackBoardAccessObject
    is a subset of the set
      $Ultralog/UltralogEntity.daml#BlackBoardObjects
]



#
# Servlet Policies
#
#     Note: Users of the servlet policy templates need not worry
#           about the policy assumptions because the servlet policy
#           templates satisfy the assumptions.
#
# Policy Assumptions:
#
#     1. Positive policies have priority two and can only involve the
#        set of users accessing the servlet and the name of the
#        servlet being accessed.
#     2. Negative policies have priority three.
#     3. Negative policies involving the authentication scheme
#        cannot involve the users.  One can only have negative
#        policies involving the user and a particular servlet in the
#        case that the policies require authentication scheme for
#        that servlet that actually identifies a user (e.g. not 
#        NoAuth or NoAuthSSL).
#     4. Policies only require Audit.  E.g. positive polices do not
#        involve audit and no policy states that audit is illegal.
#
# Justification:
#    The Servlet enforcer has two enforcement phases and the first
#     phase uses incomplete information. In order for the first phase to make
#     valid decisions assumptions 1 & 2 are necessary.  Assumption
#     three is a detail based on how mediation is performed.  A less
#     efficient mechanism would not need this assumption.
#

Policy AllowServlet = [ 
   GenericTemplate
   Priority = 2,
   $Actor.daml#Person is authorized to perform
   $Action.daml#AccessAction as long as
    the value of $Ultralog/UltralogAction.daml#accessedServlet
    is a subset of the set $Ultralog/UltralogEntity.daml#Servlet
]
