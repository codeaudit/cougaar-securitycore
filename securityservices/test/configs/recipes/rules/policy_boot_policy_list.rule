#!/usr/bin/ruby
####################################################
# create the AMnRPlaysSocietyManager.txt
# it requires enclave info to accomplish its task

if ! defined? CIP
  CIP = ENV['CIP']
end
$:.unshift File.join(CIP, 'csmart', 'assessment', 'lib')

require 'cougaar/communities'
require 'ultralog/enclaves'
require 'framework/jar_util'
require 'framework/policy_util'
require 'framework/common_security_rules'

if !(@damlBootPolicyCompleted)
  @damlBootPolicyCompleted = true
  enclave_list = []
  society.each_enclave { |enclave|
    enclave_list << enclave;
  }

  damlFile = "#{CIP}/configs/security/DamlBootPolicyList"
  origFile = "#{damlFile}.orig"
  configJar = "#{CIP}/configs/security/securityservices_config.jar"
  file = File.open(damlFile ,"w") { |file|
    file.write <<END
#
# Declarations Section
#

#
# Each of the declarations that follow defines names of policy
# concepts.  These names are used for stating and reasoning about
# policy.  However, in order for these names to be understood by the
# Ultralog enforcers, we need a mapping file that tells how Ultralog
# names are translated into policy names.  
#
# The two exceptions to this scheme are 
#  1. message verbs which are declared in Ontology-EntityInstances.daml and 
#     don't need a mapping file, and
#  2. communities which are declared in Ontology-GroupInstances.daml
#     and don't need a mapping file.
# I haven't moved the verb declarations because it requires a hack
# which I am not yet happy with.  I haven't moved the community
# declarations because they may be going away and I am concerned that
# there might be a performance hit.
#

#
# The policy prefix is prepended to each of the policy names.  It can
# be used - if desired - to arrange that built policies reside in a
# subdirectory.
#
PolicyPrefix=%DamlBootPolicy


#
# The mapping file for the following KAoS policy names is DamlUserRoleMap.
#

UserRole Administrator
UserRole CAAdministrator
UserRole General
UserRole Guest
UserRole Logistician
UserRole LogisticsViewer
UserRole MonitorManager
#{enclave_list.collect {|e| "UserRole \"x#{e.capitalize}PolicyAdministrator\"" }.join("\n")}
UserRole PolicyAdministrator
UserRole UserManager
UserRole SocietyAdmin

#
# The mapping file for the following KAoS policy names is DamlUriMap
#

Servlet AggegatorServlets
Servlet NCAServlets
Servlet SCmrmanagerServlets
Servlet DataGrabberServlet
Servlet CertReqServlet
Servlet CAReadServlet
Servlet CAWriteServlet
Servlet HierarchyServlet
Servlet LogInventoryServlet
#{enclave_list.collect {|e| "Servlet \"#{e.capitalize}PolicyServlet\"" }.join("\n")}
Servlet PolicyServlet
Servlet SocietyAdminServlet
Servlet UserManagerServlets
Servlet OtherServlets


#
# There are three mapping files for these declarations, 
#    RoleAgent        - to get the role from the agent name
#    RoleComponentMap - to get the role from the component name
#    RoleUriMap       - to get the role from the URI
#

PlugInRole OpPlanPlugIn
PlugInRole PolicyServlet
PlugInRole OrgActivityAdd
PlugInRole OrgActivityQuery
PlugInRole OrgActivityQueryNoRead
PlugInRole OrgActivityChange
PlugInRole OrgActivityRemove
PlugInRole OrgActivityAll

#
# The mapping file for these declarations is DamlBlackboardObjectMap.
#

BlackBoardObject BlackboardOpPlanObject
BlackBoardObject SafeRelay
BlackBoardObject OrgActivity

#
# End of Declarations Section
#

#
# Now the Policies follow:
#


#
# Message Passing Policies
#
#     Note: Users of the message passing policy templates need not worry
#           about the policy assumptions because the policy templates
#           satisfy the assumptions. 
#
# Policy Assumptions:
#     1. Positive policies have priority two and can only involve the
#        sender and the receiver and the verb
#     2. Negative policies have priority three and do not involve the verb.
#
#
# Justification:
#    The message enforcer has two enforcement phases and both phases
#     make decisions based on incomplete information.  In order for
#     these enforcers to make valid decisions assumptions 1 & 2 are
#     necessary. 
#


Policy AllowCommunication = [
   MessageAuthTemplate
   Allow messages from members of $Actor.daml#Agent to
   members of $Actor.daml#Agent
]


Policy EncryptCommunication = [ 
  MessageEncryptionTemplate
  Require NSAApprovedProtection on all messages from members of 
  $Actor.daml#Agent to members of $Actor.daml#Agent
]


#
# Blackboard policies
#

Policy AllowBlackboard = [ 
   GenericTemplate
   Priority = 2,
   $Ultralog/UltralogActor.daml#UltralogPlugins is authorized to perform
   $Ultralog/UltralogAction.daml#BlackBoardAccess as long as
    the value of $Ultralog/UltralogAction.daml#blackBoardAccessObject
    is a subset of the complement of the set
     { $Ultralog/Names/EntityInstances.daml#OrgActivity }
]

Policy OrgActivityAdd = [
   BlackboardTemplate
   A PlugIn in the role OrgActivityAdd can Add objects of type OrgActivity
]

Policy OrgActivityChange = [
   BlackboardTemplate
   A PlugIn in the role OrgActivityChange can Change, Query objects
   of type OrgActivity
]

Policy OrgActivityQuery = [
   BlackboardTemplate
   A PlugIn in the role OrgActivityQuery can Query objects of type OrgActivity
]

Policy OrgActivityRemove = [
   BlackboardTemplate
   A PlugIn in the role OrgActivityRemove can Remove, Query objects 
   of type OrgActivity
]

Policy OrgActivityAll = [
   BlackboardTemplate
   A PlugIn in the role OrgActivityAll can Add, Change, Query, Remove
   objects of type OrgActivity
]



#
# Servlet Policies
#
#     Note: Users of the servlet policy templates need not worry
#           about the policy assumptions because the servlet policy
#           templates satisfy the assumptions.
#
# Policy Assumptions:
#
#     1. Positive policies have priority two and can only involve the
#        set of users accessing the servlet and the name of the
#        servlet being accessed.
#     2. Negative policies have priority three.
#     3. Negative policies involving the authentication scheme
#        cannot involve the users.  One can only have negative
#        policies involving the user and a particular servlet in the
#        case that the policies require authentication scheme for
#        that servlet that actually identifies a user (e.g. not 
#        NoAuth or NoAuthSSL).
#     4. Policies only require Audit.  E.g. positive polices do not
#        involve audit and no policy states that audit is illegal.
#
# Justification:
#    The Servlet enforcer has two enforcement phases and the first
#     phase uses incomplete information. In order for the first phase to make
#     valid decisions assumptions 1 & 2 are necessary.  Assumption
#     three is a detail based on how mediation is performed.  A less
#     efficient mechanism would not need this assumption.
#

Policy UnrestServlet = [ 
   GenericTemplate
   Priority = 2,
   $Actor.daml#Person is authorized to perform
   $Action.daml#AccessAction as long as
    the value of $Ultralog/UltralogAction.daml#accessedServlet
    is a subset of the set { $Ultralog/Names/EntityInstances.daml#OtherServlets 
                             $Ultralog/Names/EntityInstances.daml#CAReadServlet 
                             $Ultralog/Names/EntityInstances.daml#CertReqServlet }
]

#
# Only require audit on CAReadServlet and CertReqServlet because
#  1. this is a common event so it allows people to see audit
#  2. I can turn on other audits in other audit experiments.
#

Policy RequireAudit = [
   AuditTemplate
   Require audit for all accesses to all servlets
]

#{enclave_list.collect {|e| "Policy PolicyServlet#{e.capitalize} = [
  ServletUserAccessTemplate
  A user in role \"x#{e.capitalize}PolicyAdministrator\" can access a servlet 
  named \"#{e.capitalize}PolicyServlet\"
]

Policy PolicyServlet#{e.capitalize}Auth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named \"#{e.capitalize}PolicyServlet\"
]
"}.join("\n")}

Policy PolicyServlet  = [ 
  ServletUserAccessTemplate
  A user in role PolicyAdministrator can access a servlet 
  named PolicyServlet
]

Policy PolicyServletAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named PolicyServlet
]

Policy SCmrManager  = [ 
  ServletUserAccessTemplate
  A user in role MonitorManager can access a servlet named SCmrmanagerServlets
]

Policy SCmrManagerAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named SCmrmanagerServlets
]

Policy NCAServlet = [
  ServletUserAccessTemplate
  A user in role Logistician can access a servlet named NCAServlets
]

Policy NCAServletAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named NCAServlets
]

Policy LogisticianAgg = [
  ServletUserAccessTemplate
  A user in role Logistician can access a servlet named AggegatorServlets
]

Policy LogisticianAggAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named AggegatorServlets
]

Policy LogisticianViewAgg = [
  ServletUserAccessTemplate
  A user in role LogisticsViewer can access a servlet named AggegatorServlets
]

Policy LogisticianViewAggAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named AggegatorServlets
]

Policy UserAdminServlets = [
  ServletUserAccessTemplate
  A user in role UserManager can access a servlet named UserManagerServlets
]

Policy UserAdminServletsAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named UserManagerServlets
]

Policy LogisticianInventory = [
  ServletUserAccessTemplate
  A user in role Logistician can access a servlet named LogInventoryServlet
]

Policy LogisticianInventoryAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named LogInventoryServlet
]

Policy LogisticsViewerInventory = [
  ServletUserAccessTemplate
  A user in role LogisticsViewer can access a servlet named LogInventoryServlet
]

Policy LogisticsViewerInventoryAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named LogInventoryServlet
]

Policy LogisticianHierarchy = [
  ServletUserAccessTemplate
  A user in role Logistician can access a servlet named HierarchyServlet
]

Policy LogisticianHierarchyAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named HierarchyServlet
]

Policy LogisticsViewerHierarchy  = [
  ServletUserAccessTemplate
  A user in role LogisticsViewer can access a servlet named HierarchyServlet
]

Policy LogisticsViewerHierarchyAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named HierarchyServlet
]

Policy CertWrite  = [
  ServletUserAccessTemplate
  A user in role CAAdministrator can access a servlet named CAWriteServlet
]

Policy CertWriteAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named CAWriteServlet
]

Policy SocietyAdmin = [
  ServletUserAccessTemplate
  A user in role SocietyAdmin can access a servlet named SocietyAdminServlet
]

Policy SocietyAdminAuth  = [ 
  ServletAuthenticationTemplate
  All users must use Password, PasswordSSL, CertificateSSL
  authentication when accessing the servlet named SocietyAdminServlet
]

END
  }
  lines1 = File.readlines(damlFile)
  begin
    lines2 = File.readlines(origFile)
  rescue
    lines2 = []
  end
  if (lines2 != lines1)
    output = policyUtil("--maxReasoningDepth 150 build --info #{damlFile}",
                        nil, "#{CIP}/configs/security")
    replaceFileInJar(configJar, damlFile)
    Dir["#{CIP}/configs/security/*.info"].each { |file|
      replaceFileInJar(configJar, file)
    }
    signJar(configJar, "#{CIP}/operator/signingCA_keystore",            
                        "privileged")
    File.open(origFile,"w") { |file|
      file.print(lines1.join)
    }
  end
end
