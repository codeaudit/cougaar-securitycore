/*
 * <copyright>
 *  Copyright 1997-2003 Cougaar Software, Inc.
 *  under sponsorship of the Defense Advanced Research Projects
 *  Agency (DARPA).
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Cougaar Open Source License as published by
 *  DARPA on the Cougaar Open Source Website (www.cougaar.org).
 *
 *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS
 *  PROVIDED "AS IS" WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR
 *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT
 *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT
 *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL
 *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS,
 *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THE COUGAAR SOFTWARE.
 *
 * </copyright>
 *
 * CHANGE RECORD
 * -
 */

package org.cougaar.core.security.crypto.blackboard;

import java.util.*;
import java.security.cert.X509Certificate;
import java.security.PrivateKey;

// Cougaar core services
import org.cougaar.core.service.BlackboardService;
import org.cougaar.core.service.LoggingService;
import org.cougaar.core.component.ServiceBroker;
import org.cougaar.core.component.ServiceAvailableListener;
import org.cougaar.core.component.ServiceAvailableEvent;
import org.cougaar.util.UnaryPredicate;

// Cougaar security services
import org.cougaar.core.security.services.util.CACertDirectoryService;
import org.cougaar.core.security.crypto.ldap.CertificateRevocationStatus;
import org.cougaar.core.security.crypto.CertificateType;
import org.cougaar.core.security.crypto.CertificateUtility;
import org.cougaar.core.security.naming.CertificateEntry;

public class CACertDirectoryServiceImpl
  implements CACertDirectoryService
{
  private ServiceBroker _serviceBroker;
  private BlackboardService _blackboardService;
  private LoggingService _log;
  private CertificateBlackboardStore _certStore;

  public CACertDirectoryServiceImpl(ServiceBroker sb) {
    _serviceBroker = sb;
    _log = (LoggingService)_serviceBroker.getService
      (this, LoggingService.class, null);

    BlackboardService bbs = (BlackboardService)
      _serviceBroker.getService(this,
			       BlackboardService.class,
			       null);
    if(bbs==null) {
      if (_log.isDebugEnabled()) {
	_log.debug("Adding service listner for blackboard service :");
      }
      _serviceBroker.addServiceListener(new BlackboardServiceAvailableListener());
    }
    else {
      setBlackboardService();
    }
  }

  /**
   * Publish a certificate (managed by a CA) in the blackboard.
   * The certificate is assumed to be valid.
   */
  public void publishCertificate(X509Certificate cert, int type, PrivateKey privatekey) {
    if (_blackboardService == null) {
      throw new RuntimeException("Blackboard service not yet available");
    }
    if (_log.isDebugEnabled()) {
      _log.debug("Publish certificate: " + cert.toString());
    }
    // Assume the certificate is valid if we publish it.
    CertificateRevocationStatus certStatus = CertificateRevocationStatus.VALID;
    CertificateType certType = null;
    switch (type) {
    case CertificateUtility.CACert:
      certType = CertificateType.CERT_TYPE_CA;
      break;
    default:
      certType = CertificateType.CERT_TYPE_END_ENTITY;
    }
    CertificateEntry certEntry = new CertificateEntry(cert,
						      certStatus, certType);
    publishCertificate(certEntry);
  }

  /**
   * Publish a certificate (managed by a CA) in the blackboard
   */
  public void publishCertificate(CertificateEntry certEntry) {
    String dnname = certEntry.getCertificate().getSubjectDN().getName();
    if (_log.isDebugEnabled()) {
      _log.debug("Publish certificate: " + dnname);
    }

    synchronized(_certStore) {
      List certList = (List)_certStore.get(dnname);
      if (certList == null) {
	certList = new ArrayList();
      }
      int index = certList.indexOf(certEntry);
      if (index == -1) {
	// New entry
	certList.add(certEntry);
      }
      else {
	// Entry is being modified
	certList.set(index, certEntry);
      }
      // Add entry for DN and Unique ID so that we can search using both strings
      _certStore.put(dnname, certList);
      _certStore.put(certEntry.getUniqueIdentifier(), certEntry);
    }

    _blackboardService.publishChange(_certStore);
    // Persist the blackboard so that keys generated by the CA are not accidentaly lost
    // by an agent crash.
    try {
      _blackboardService.persistNow();
    }
    catch (Exception e) {
      _log.info("Persistence is not enabled. Certificates will not be persisted");
    }
  }

  /**
   * Return a list of all the certificates managed by the CA, including the CA itself.
   */
  public List getAllCertificates() {
    if (_log.isDebugEnabled()) {
      _log.debug("Get all certificates");
    }
    Enumeration enum = _certStore.elements();
    List completeList = new ArrayList();
    while (enum.hasMoreElements()) {
      Object o = enum.nextElement();
      if (o instanceof List) {
	completeList.addAll((List)o);
      }
    }
    return completeList;
  }

  /**
   * Find a list of certificates matching a distinguished name.
   * @param identifier - The distinguished name of the certificate to look for.
   */
  public List findCertByDistinguishedName(String distinguishedName) {
    if (_log.isDebugEnabled()) {
      _log.debug("Get certificates for " + distinguishedName);
    }
    List certList = (List)_certStore.get(distinguishedName);
    return certList;
  }

  /**
   * Find a certificate given its unique identifier.
   * @param identifier - The unique identifier of the certificate to look for.
   */
  public CertificateEntry findCertByIdentifier(String uniqueIdentifier) {
    if (_log.isDebugEnabled()) {
      _log.debug("Get certificates for " + uniqueIdentifier);
    }
    CertificateEntry certEntry = (CertificateEntry)_certStore.get(uniqueIdentifier);
    return certEntry;
  }

  /** Set the blackboard service and initialize the Certificate
   *  Blackboard Store.
   */
  private final synchronized void setBlackboardService() {
    _blackboardService = (BlackboardService)
      _serviceBroker.getService(this,BlackboardService.class, null);

    Collection collection = null;
    if(_blackboardService.didRehydrate()) {
      // Retrieve persisted instance of the Certificate Blackboard Store.
      // There should be only one instance of the the Certificate Store.
      collection =
	_blackboardService.query(new CertificateBlackboardStorePredicate());
      if (collection.size() > 1) {
	throw new RuntimeException
	  ("Can support at most one CertificateBlackboardStore. Current items:" + collection.size());
      }
      if (collection.isEmpty()) {
	collection = null;
      }
      else {
	Iterator it = collection.iterator();
	_certStore = (CertificateBlackboardStore) it.next();
      }
    }
    if (!_blackboardService.didRehydrate() || collection == null) {
      _certStore = new CertificateBlackboardStore();
      _blackboardService.publishAdd(_certStore);
    }
  }

  /** Service listener for the Blackboard Service.
   *  Set the blackboard service when it becomes available.
   */
  private class BlackboardServiceAvailableListener implements ServiceAvailableListener {
    public void serviceAvailable(ServiceAvailableEvent ae) {
      Class sc = ae.getService();
      if(org.cougaar.core.service.BlackboardService.class.isAssignableFrom(sc)) {
	if(_blackboardService==null){
	  _log.debug("BB Service is now available");
	  setBlackboardService();
	}
      }
    }
  }

  private class CertificateBlackboardStorePredicate implements UnaryPredicate {
    public boolean execute(Object o) {
      boolean ret = false;
      if (o instanceof CertificateBlackboardStore) {
	return true;
      }
      return ret;
    }
  }

  private class CertificateBlackboardStore extends Hashtable {
  }
}
