<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head>  <title></title></head>  <body><H1>DAML Policy Management</H1>In this section, we will go through all of the different types ofpolicies that are used by policy management.  We will give an exampleof each type of policy, showing how the policy is represented bothfor the command line tool and for the visual KPaT policy tool.  Foreach of these policies we given an example of the policy and describewhat configuration files are needed to manipulate the policy.<H2>Communication Policies</H2>There are two types of communication policies.  The firstcommunication policies allow and deny communication betwween agents.An example of such a policy is the following (from the boot policies):<pre>  Policy AllowCommunication = [     MessageAuthTemplate     Allow messages from members of $Actor.owl#Agent to     members of $Actor.owl#Agent  ]</pre>This policy allows communication between any agents.  In KPAT thispolicy looks as follows:<div align="center"><img src="../img/AllowCommunicationPolicy.jpg" alt="Main Screen">    <br> </div>  <br>There are several variations on these types of policies that arepossible.  We can allow or deny communications, we can select specificagents and we can can specify the message content.  An example of apolicy that includes these ingredients is the following:<div align="center"><img src="../img/DenySomePolicy.jpg" alt="Main Screen">    <br> </div>  <br><p>In order to have a policy involving the contents of a message, thetypes of message contents must be listed in the configuration fileOwlMapVerbs.<p>While the command line tool cannot specify the message contents, itdoes have the extra feature that it can involve groups of agents.  Anexample of such a policy is the following:<pre>  Agent testBounceOne  Agent testBounceTwo  AgentGroup Bouncers = { testBounceOne, testBounceTwo }  Policy DenyBounce = [      MessageAuthTemplate     Deny messages from members of $AgentsInGroup#Bouncers to members of     $AgentsInGroup#Bouncers   ]</pre>The agent declarations are not neccessary if the policy is committedto a running society that already has these agents on it.<p>The other type of communication policy are the communication policiesthat describe the type of encryption that must be  used in amessage.  These types of policies cannot involve the contents of themessage because the contents of a message is not available at thepoint in time at which the message is decrypted.  An example of sucha policy with the command line tool is as follows:<pre>  Policy EncryptCommunicationTwo = [    MessageEncryptionTemplate    Require NSAApprovedProtection on all messages from members of     $AgentsInGroup#RearPolicyDomainManagerGroup to members of     $AgentsInGroup#NodeAgents  ]</pre>We can also specify  the complement of a set as in the followingpolicy:<pre>  Policy EncryptCommunicationThree = [    MessageEncryptionTemplate    Require WeakProtection on all messages from members of the    complement of    $AgentsInGroup#RearPolicyDomainManagerGroup to members of the    complement of    $AgentsInGroup#NodeAgents  ]</pre>In KPAT an example of such a policy would be the following:<div align="center"><img src="../img/EncryptionPolicy.jpg" alt="Main Screen">    <br> </div>  <br><H2>Servlet Policies</H2>There are three types of servlet policies.  The first type of policiesdefine which user roles are needed to access which servlets. Thesecond type of policy defines what authentication scheme isnecessary.  The third type of policy defines which successfulaccesses to servlets must be auditted.  (Unsuccessful access attemptsare always audited.) Servlet policies involve some additional configurationfiles that need to be configured correctly.<p>An example of a command line servlet policy that allows users toaccess a servlet is the following:<pre>  Policy LogisticianAgg = [    ServletUserAccessTemplate    A user in role Logistician can access a servlet named AggegatorServlets  ]</pre>In KPAT, this policy looks as follows:<div align="center"><img src="../img/UserAccessPolicy.jpg" alt="Main Screen">    <br> </div><br>User servlet access policies can allow or deny access to a servlet.<p>In order for the Ultra*Log system to make sense of these policies weneed to have configuration files that define what is meant by theLogistician role and what is meant by AggregatorServlets.  This isdone in three configuration files.  First, the Logistician role andthe AggregatorServlets must be declared to the policy system.  Thisis done in a policy file, usually the boot policy file.  Thesedeclarations have the following form:<pre>  UserRole Logistician  Servlet AggegatorServlets</pre>(Note that with csmart, the boot policy is generated in the rule,policy_boot_policy_list.rule.)  To map the role Logistician to itsmeaning in the Ultra*Log system, we have the following declaration inthe file OwlMapUserRole:<pre>  .*\\Logistician Logistician</pre>This line indicates that the role Logistician in any user domain mapsto the role Logistician.  An example where the user domain is importantis in the following declaration:<pre>  RearUserDomainComm\\PolicyAdministrator RearPolicyAdministrator</pre>(Note that with csmart, the OwlMapUserRole file is generated in therule policy_user_role_map.rule.)</p>Similarly Aggregator servlets is mapped to the set of servlets itrepresents in the file OwlMapUri:<pre>  /\$AGG-Agent/aggregator AggegatorServlets</pre>Multiple servlet names can be mapped to the same policy name as inthe following declarations:<pre>  /\$NCA/glsinit NCAServlets  /\$NCA/glsreply NCAServlets  /\$NCA/editOplan NCAServlets</pre><p>The second type of servlet policy defines what type of userauthentication must be used to access a servlet.  An example of sucha policy is given by the command line policy:<pre>  Policy UserAdminServletsAuth  = [     ServletAuthenticationTemplate    All users must use Password, PasswordSSL, CertificateSSL    authentication when accessing the servlet named UserManagerServlets  ]</pre>In KPAT only one authentication scheme can be selected.  An exampleof such a policy is the following:<div align="center"><img src="../img/UserManagerAuthPolicy.jpg" alt="Main Screen">    <br> </div><br><p>Finally, there are the policies that define when successful servletaccess attempts must be auditted.  The following is an exmaple ofsuch a command line policy:<pre>  Policy RequireAuditCA = [     AuditTemplate     Require audit for all accesses to servlet CAReadServlet,     CertReqServlet, CAWriteServlet     by users in role Guest  ]</pre>This policy  is represented in KPAT as the policy:<div align="center"><img src="../img/ServletAuditPolicy.jpg" alt="Main Screen">    <br> </div><br><H2>Blackboard Access Policies</H2>Blackboard access policies define which plugins, user servlets orcomponents can access objects on the blackboard.  The policies controlquery, add, change and remove accesses to the blackboard An example of sucha policy for the command line tool is <pre>  Policy OrgActivityAdd = [     BlackboardTemplate     A PlugIn in the role OrgActivityAdd can Add objects of type OrgActivity  ]</pre>This policy is expressed in KPAT as <div align="center"><img src="../img/BlackboardPolicy.jpg" alt="Main Screen">    <br> </div><br><p>In order to make sense of this policy, the Ultra*Log system needs toknow the meaning of the OrgActivityChange role and the OrgActivityblackboard object.  This is arranged in three files, the boot policy,OwlMapRoleUri and OwlMapBlackboardObjects.<p>First the role and the object are declared in some policy file(usually the boot policy file):<pre>  PlugInRole OrgActivityAdd  BlackBoardObject OrgActivity</pre>The role OrgActivityAdd is mapped to its Ultra*Log meaning inOwlMapRoleUri:<pre>  /$testBBPolicyAgent/OrgActivityAdd http://ontology.ihmc.us/Ultralog/Names/EntityInstances.owl#OrgActivityAddRole</pre>The object OrgActivity is mapped to its Ultra*Log meaning inOwlMapBlackboardObjects: <pre>org.cougaar.glm.ldm.oplan.OrgActivity http://ontology.ihmc.us/Ultralog/Names/EntityInstances.owl#OrgActivity</pre> <H1>Reading Permission Denied Logs</H1>When the policy denies access to a resource, a permission deniedwarning is placed in the logs.  These messages are currently somewhatarcane and difficult to read.  However, they are very useful forunderstanding policy errors.  Here is an example where a user in theFwdUserDomainComm attempts to access the rear enclave policy domain manager.The error in the logs is as follows:<pre>21:33:59,375 WARN  - ServletNodeEnforcer - Permission denied21:33:59,376 WARN  - ServletNodeEnforcer - Action =     _actionClassName: http://ontology.ihmc.us/Ultralog/UltralogAction.owl#ServletAccess    _actor: ----User614    _targets: [kaos.ontology.repository.TargetInstanceDescription@c0f040, kaos.ontology.repository.TargetInstanceDescription@b76b89, kaos.ontology.repository.TargetInstanceDescription@a6ffe5]    _conceptMappingName:KAoS    _actor:   Name: http://ontology.ihmc.us/Action.owl#performedBy  Class: null  Restriction Type: null  isComplement false  instances: [----User614]    _action:   Name: http://ontology.ihmc.us/Action.owl#Action  Class: null  Restriction Type: null  isComplement false  instances: [http://ontology.ihmc.us/Ultralog/UltralogAction.owl#ServletAccess]    _targetRoleNames: [http://ontology.ihmc.us/Ultralog/UltralogAction.owl#accessedServlet, http://ontology.ihmc.us/Ultralog/UltralogAction.owl#usedAuditLevel, http://ontology.ihmc.us/Ultralog/UltralogAction.owl#usedAuthenticationLevel]    _properties: http://ontology.ihmc.us/Ultralog/UltralogAction.owl#usedAuditLevel   Name: http://ontology.ihmc.us/Ultralog/UltralogAction.owl#usedAuditLevel  Class: null  Restriction Type: null  isComplement false  instances: [http://ontology.ihmc.us/Ultralog/Names/EntityInstances.owl#Audit]http://ontology.ihmc.us/Ultralog/UltralogAction.owl#usedAuthenticationLevel   Name: http://ontology.ihmc.us/Ultralog/UltralogAction.owl#usedAuthenticationLevel  Class: null  Restriction Type: null  isComplement false  instances: [http://ontology.ihmc.us/Ultralog/Names/EntityInstances.owl#Password]http://ontology.ihmc.us/Ultralog/UltralogAction.owl#accessedServlet   Name: http://ontology.ihmc.us/Ultralog/UltralogAction.owl#accessedServlet  Class: null  Restriction Type: null  isComplement false  instances: [http://ontology.ihmc.us/Ultralog/Names/EntityInstances.owl#RearPolicyServlet]21:33:59,378 WARN  - ServletNodeEnforcer - User ----User614 in roles [SocietyAdmin, UserManager, MonitorManager, Logistician, PolicyAdministrator, LogisticsViewer, CAAdministrator]</pre>There are three log messages above.  The first message indicates thatthe access is denied, the second describes the action being deniedand the third provides additional supplemental information (which isoften specific to the action type).<p>The most important two things to discover about the action beingdenied is the actor performing the action and the type of actionbeing performed.  The action being performed is identified bythe "actor:" line in the action description.  We see that  thisaction is performed by the actor User614.  There is another "actor:"line a couple of lines below the first one.  The second version hasan expanded description of the actor as a KAoSProperty.  TheKAoSProperty  indicates that the actor is given by who the action is"performedBy".  Again the actor is given as User614.<p>By looking at the "action:" line we see that the action is aServletAccess action.  Continuing down the logs  we see that<ul><li> the "usedAuditLevel" is "Audit".<li> the "usedAuthenticationLevel" is "Password"<li> the "accessedServlet is RearPolicyServlet.</ul><p>User614 is an internal Ultra*Log name for the user who attempted tologin.  The real login name  for the user is not used here.Therefore we have to go to the supplemental information in the thirdlog statement.  This statement indicates that user User614 is in theroles SocietyAdmin, UserManager, MonitorManager, Logistician,PolicyAdministrator, LogisticsViewer, and CAAdministrator.  <p>This ends the examination of the log file entries.  If we then examine the boot policies we discover the problem.  Theboot polices require that anyone accessing theRearPolicyServlet be in the role "xRearPolicyAdministrator" (the namexRearPolicyAdministrator is generated automatically by the rulepolicy_boot_policy_list.rule.)   The relevant policy is<pre>  Policy PolicyServletRear = [    ServletUserAccessTemplate    A user in role "xRearPolicyAdministrator" can access a servlet     named "RearPolicyServlet"  ]</pre>Without this role access is denied.<H1>Configuration Files</H1><p>The central configuration file for the policy mechanism is theDamlBootPolicyList configuration file. This file defines the bootpolicies and defines the names that the policy mechanisms use torepresent objects in the system. The DamlBootPolicyList also containssome comments documenting the usage of various declarations and therestrictions on what policies can be written. The grammar for theDamlBootPolicyList file can be found in Policy Grammar.<p>The next most important set of configuration files are those that map policy concept to the objects that they represent in the Ultralog system. For example consider the name RearPolicyServlet which occurs in the following boot policy:<pre>   Policy PolicyServletRear = [       ServletUserAccessTemplate        A user in role RearPolicyAdministrator can access a servlet        named RearPolicyServlet   ]</pre>The name RearPolicyServlet, which is used in the policy language,represents any servlet that is accessed through a URI of the form: <ul><li> /$RearPolicyDomainManagerServlet/policyAdmin</ul>This mapping from the Ultralog concept<ul><li> /$RearPolicyDomainManagerServlet/policyAdmin</ul>to the policy name<ul><li> RearPolicyServlet</ul>is defined by the following line in the configuration file DamlUriMap:<ul><li> /$RearPolicyDomainManagerServlet/policyAdmin RearPolicyServlet.</ul><p>DamlUriMap is an example of a policy mapping file and all the mappingfiles have this format. The format consists of lines consisting of theUltralog name followed by a space and then the policy name. Wild cardsare allowed and when the enforcement mechanisms try to match anUltralog name with a policy name, the first match wins. <p>Declarations in DamlBootPolicyList of the form<ul><li> UserRole Administrator</ul>represent user roles for the servlet access control policies. Themapping file is DamlUserRoleMap. Declarations in DamlBootPolicyList of the form<ul><li> Servlet AggegatorServlets</ul>represent servlets. The mapping file is DamlUriMap.Declarations of the form<ul><li> PlugInRole OpPlanPlugInRole</ul>represent plugins that attempt to access the blackboard. There arethree mapping files for mapping Ultralog PlugiIn names to policynames: <ol><li> RoleAgent for the case when the role for the plugin is obtainedfrom the containing agent. <li> RoleComponentMap for the case when the role for the plugin isobtained from the component name. <li>  RoleUriMap for the case when the role for the plugin is obtainedfrom the URI for the servlet the PlugIn is implementing. </ol>Declaraions of the form<ul><li> BlackBoardObject BlackboardOpPlanObject</ul>represent names for blackboard objects. The mapping file isDamlBlackboardObjectMap. There are two other configuration files that are needed to get servlet authentication to work:<i> UserFile.xml</i>This file defines the users for the system, their passwords and their roles.<i> Communities.xml</i>In order to do access mediation on a servlet, a node must be able tocontact the user manager. A node finds its user manager through thecommunity service. The node looks for User communities that it belongsto: <pre>   <Community Name="RearUserDomainComm" >       <Attribute ID="CommunityType" Value="User" /></pre>which have a declared user manager in them:<pre>        <Entity Name="RearUserAdminAgent" >          <Attribute ID="EntityType" Value="Agent" />          <Attribute ID="Role" Value="Member" />          <Attribute ID="Role" Value="UserManager" />        </Entity></pre><i>Testing</i><p>DamlTestAgents<p> DamlTestRoles<p>DamlTestUris<i>Command Line Tools</i><p>PolicyUtil is a command line tools for manipulating policies. It canbe found in the securityservices directory, test/bin. If you run it byitself it will print out some help messages.<p>To initialize the policies on KPAT, I might run the command<p>policyUtil commit --dm localhost 8801 RearPolicyDomainManagerServlet DamlBootPolicyList<p>in the securityservices/test/configs/common directory. This commandwill take the policies defined in the DamlBootPolicyList file and sendthem to the domain manager to be committed. If you run KPAT after thiscommand completes, you will see a set of (about 42) policies there. <ul><li> The "--dm" option means that the policies are constructed on the     fly. An alternative to the "--dm" option is the following two     commands:      <ul>     <li> policyUtil build DamlBootPolicyList     <li>  policyUtil commit localhost 8801 RearPolicyDomainManagerServlet DamlBootPolicyList     </ul>     The first of these two commands will build a set of .msg policy     files. The second command will send those .msg files to the     domain manager. The advantage of not using the "--dm" option is     that the commit step is faster. The policy build only needs to be     done once. The advantage of using the "--dm" option is that you     don't have to worry about the possibility that the .msg files are     out of sync with the policies in the DamlBootPolicyList file. In     other words, maybe you did the build step a long time ago and the     DamlBootPolicyList changed in the mean time. </ul>When building policies, the policyUtil command concatenates the policyprefix with the name of the policy to determine the name for thepolicy .msg file. Thus in DamlBootPolicyList, the policy prefix isdefined by the line <pre> PolicyPrefix=%DamlBootPolicy</pre>and there is a policy defined by<pre> Policy AllowCommunication = [  MessageAuthTemplate    Allow messages from members of $Actor.daml#Agent to    members of $Actor.daml#Agent ]</pre>So after a build there will be a policy fileDamlBootPolicyAllowCommunication.msg that allows all cougaarcommunication. I sometimes use the policy prefix to ensure that thepolicies are written to a different directory. <p>I also have a set of sample policies insecurityservices/test/configs/policies. There are two kinds offiles. The *.policy files are complete policies. If this set ofpolicies replaces the current policies then the system should be ableto continue running. Thus <ul><li> policyUtil commit --dm localhost 8801 RearPolicyDomainManagerServlet AlmostAllow.policy</ul>will set the policies to be a very short and permissive set ofpolicies. AlmostAllow.policy does require encryption on Ultralogmessages though because there can be problems when changing theencryption policy. Allow.policy does not require encryption onUltralog messages. The Allow.policy policy is a littel problematicbecause the transition from using encryption to not using encryptioncan cause some agents to be unable to communicate. <p>I also have policy files of the form *.delta. These policies are not meant to replace the current policies but to modify them. Thus for instance the AllowFwdPolicyServlet.delta is a policy that allows you to log in to the domain manager servlet with a user name of<ul><li> FwdUserDomainComm\george</ul>(and a password of george). If you were to execute the command<ul><li> policyUtil commit --dm localhost 8801 RearPolicyDomainManagerServlet AllowFwdPolicyServlet.delta</ul>then the system would either break or be crippled. There are not enough policies in AllowFwdPolicyServlet.delta to make the system work properly. Instead you can execute the commands:<H1>Configuration Done By CSmart</H1><H2>Flags</H2><p><i>Servlet Access Control</i><p>Servletaccess control is responsible for making decisions about whether a usershould be allowed to access aservlet.  It also controls whichservlet access operations are audited.It uses the following flags:<UL><LI> org.cougaar.core.security.policy.enforcers.servlet.useDaml=true     <ul>     <LI> This flag enables the daml enforcement mechanisms.     </ul><li> org.cougaar.lib.web.tomcat.enableAuth=true     <ul>     <li> Thisflag turns on the authentication mechanisms.     </ul><li> org.cougaar.core.security.audit=true     <ul>     <li> This flag enables audit mechanisms which are also protected          by policy.      </ul></ul><p><i>Message Passing Access Control</i><p>Message passing access control is responsible for controlling ultralogmessaging. There are two types of controls that we currently set:whether the message can be sent or received and how the message shouldbe cryptographically protected. This mechanism uses the followingflags:<ul><li> org.cougaar.core.security.policy.enforcers.crypto.useDaml=true     <ul>     <li> This flag enables the daml enforcement mechanisms for          questions of whether messages should be cryptographically          protected.      </ul><li> org.cougaar.core.security.policy.enforcers.access.useDaml=true      <ul>      <li> This flag enables the daml enforcement mechanisms for           questions of whether messages should be sent or received based           on their content and the sender and the receiver.       </ul></ul><p><i>BlackBoard Access Control</i><p>The Blackboard access control mechanism controls access of plugins tothe blacboard. <ul><li> org.cougaar.core.security.policy.auth.role.useDaml=true     <ul>     <li> This flag controls whether blackboard access control is           turned on.     </ul><li> org.cougaar.core.security.policy.auth.role.useAccessCaching=true     <ul>     <li> This flag causes the enforcement mechanisms to cache the          knowledge that an access to the blackboard is allowed. The          blackboard is heavily accessed during normal operations (much          more so than Ultralog messaging) and it is recommended that this          flag be turned on is blackboard access control is enabled.       </ul><li> org.cougaar.core.security.access.efficientBBS=true     <ul>     <li> When this flag is turned on, blackboard access control is          only utilized for blackboard objects that are subclasses of          SecuredObject.      </ul><p><i>Other</i><ul><li> safe.guard.NodeGuard.createPolicies=false     <ul>     <li> This flag is obsolete and should always be set to false.     </ul></ul><H2>Loaded Components</H2><ul><li> Node.AgentManager.Agent.SecurityComponent(HIGH)=org.cougaar.core.security.policy.webproxy.WebProxySecurityComponent()     <ul>     <li> This component is recommended on every component that hosts          a domain manager. This component intercepts all client web          requests. Those web requests that represent an attempt to obtain          DAML ontologies from the Institute for Machine and Human          Cognition (ihmc) web site are redirected to the configuration          files. There are two reasons why this component is          recommended. First, there are synchronization issues between the          Ultra*Log ontologies and the ontologies on the ihmc web          site. Second, the use of configuration files to supply ontologies          is faster and more self-sufficient.      </ul><li>Node.AgentManager.Agent.SecurityComponent(HIGH)=safe.util.SAFESecurityComponent(EnclaveOnePolicyManager,EnclaveOne)    <ul>    <li> This component should be started on every node. This         component starts the KAoS guard with is responsible for disclosing         answers to policy questions to clients. For example an enforcer         for servlet access might ask if the current policy allows a given         action.     </ul><li>Node.AgentManager.Agent.SecurityComponent(HIGH)=org.cougaar.core.security.provider.SecurityComponentFactory(community)<li> Node.AgentManager.Agent.SecurityComponent(HIGH)=org.cougaar.core.security.crypto.AutoConfigPlugin(eucalyptus:ca1ADAgent)    <ul>    <li> This component is needed to obtain certificates. It is needed         by the message passing and servlet enforcement engines.     </ul><li> Node.AgentManager.Agent.MessageTransport.Aspect(INTERNAL)=org.cougaar.core.security.crypto.MessageProtectionAspectImpl<li> Node.AgentManager.Agent.PluginManager.Binder(BINDER)=org.cougaar.core.security.access.PluginServiceFilter<li> Node.AgentManager.Binder(BINDER)=org.cougaar.core.security.access.AccessAgentBinderFactory<li> plugin =org.cougaar.core.security.policy.enforcers.init.InitAgentPlugin()     <ul>     <li> This component is required on every agent. It ensures that          the domain manager is properly informed about the agent.      </ul><li> plugin = org.cougaar.community.CommunityPlugin     <ul>     <li> This component ensures that the community service works. It          is required on every node. It is needed by the servlet          enforcement mechanisms to find the agents that handle user login          and authentication.      </ul><li> plugin=org.cougaar.core.security.policy.enforcers.init.InitNodePlugin()     <ul>     <li> This component is useful for testing the state of          policies. It tests policies involving communication and servlet          access.      </ul></ul></body>