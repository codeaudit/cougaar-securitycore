<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head>  <title></title></head>  <body><H1>Configuration Files</H1><p>This section documents some of hte configuration settings that areneeded to set up the policy mechanisms.  They are generally set up bycsmart rules.  Generally the policy administrator should not have totouch these settings.<p>The central configuration file for the policy mechanism is theDamlBootPolicyList configuration file. This file defines the bootpolicies and defines the names that the policy mechanisms use torepresent objects in the system. The DamlBootPolicyList also containssome comments documenting the usage of various declarations and therestrictions on what policies can be written. The grammar for theDamlBootPolicyList file can be found in Policy Grammar.<p>The next most important set of configuration files are those that map policy concept to the objects that they represent in the Ultralog system. For example consider the name RearPolicyServlet which occurs in the following boot policy:<pre>   Policy PolicyServletRear = [       ServletUserAccessTemplate        A user in role RearPolicyAdministrator can access a servlet        named RearPolicyServlet   ]</pre>The name RearPolicyServlet, which is used in the policy language,represents any servlet that is accessed through a URI of the form: <ul><li> /$RearPolicyDomainManagerServlet/policyAdmin</ul>This mapping from the Ultralog concept<ul><li> /$RearPolicyDomainManagerServlet/policyAdmin</ul>to the policy name<ul><li> RearPolicyServlet</ul>is defined by the following line in the configuration file DamlUriMap:<ul><li> /$RearPolicyDomainManagerServlet/policyAdmin RearPolicyServlet.</ul><p>DamlUriMap is an example of a policy mapping file and all the mappingfiles have this format. The format consists of lines consisting of theUltralog name followed by a space and then the policy name. Wild cardsare allowed and when the enforcement mechanisms try to match anUltralog name with a policy name, the first match wins. <p>Declarations in DamlBootPolicyList of the form<ul><li> UserRole Administrator</ul>represent user roles for the servlet access control policies. Themapping file is DamlUserRoleMap. Declarations in DamlBootPolicyList of the form<ul><li> Servlet AggegatorServlets</ul>represent servlets. The mapping file is DamlUriMap.Declarations of the form<ul><li> PlugInRole OpPlanPlugInRole</ul>represent plugins that attempt to access the blackboard. There arethree mapping files for mapping Ultralog PlugiIn names to policynames: <ol><li> RoleAgent for the case when the role for the plugin is obtainedfrom the containing agent. <li> RoleComponentMap for the case when the role for the plugin isobtained from the component name. <li>  RoleUriMap for the case when the role for the plugin is obtainedfrom the URI for the servlet the PlugIn is implementing. </ol>Declaraions of the form<ul><li> BlackBoardObject BlackboardOpPlanObject</ul>represent names for blackboard objects. The mapping file isDamlBlackboardObjectMap. There are two other configuration files that are needed to get servlet authentication to work:<i> UserFile.xml</i>This file defines the users for the system, their passwords and their roles.<i> Communities.xml</i>In order to do access mediation on a servlet, a node must be able tocontact the user manager. A node finds its user manager through thecommunity service. The node looks for User communities that it belongsto: <pre>   <Community Name="RearUserDomainComm" >       <Attribute ID="CommunityType" Value="User" /></pre>which have a declared user manager in them:<pre>        <Entity Name="RearUserAdminAgent" >          <Attribute ID="EntityType" Value="Agent" />          <Attribute ID="Role" Value="Member" />          <Attribute ID="Role" Value="UserManager" />        </Entity></pre><i>Testing</i><p>DamlTestAgents<p> DamlTestRoles<p>DamlTestUris<i>Command Line Tools</i><p>PolicyUtil is a command line tools for manipulating policies. It canbe found in the securityservices directory, test/bin. If you run it byitself it will print out some help messages.<p>To initialize the policies on KPAT, I might run the command<p>policyUtil commit --dm localhost 8801 RearPolicyDomainManagerServlet DamlBootPolicyList<p>in the securityservices/test/configs/common directory. This commandwill take the policies defined in the DamlBootPolicyList file and sendthem to the domain manager to be committed. If you run KPAT after thiscommand completes, you will see a set of (about 42) policies there. <ul><li> The "--dm" option means that the policies are constructed on the     fly. An alternative to the "--dm" option is the following two     commands:      <ul>     <li> policyUtil build DamlBootPolicyList     <li>  policyUtil commit localhost 8801 RearPolicyDomainManagerServlet DamlBootPolicyList     </ul>     The first of these two commands will build a set of .msg policy     files. The second command will send those .msg files to the     domain manager. The advantage of not using the "--dm" option is     that the commit step is faster. The policy build only needs to be     done once. The advantage of using the "--dm" option is that you     don't have to worry about the possibility that the .msg files are     out of sync with the policies in the DamlBootPolicyList file. In     other words, maybe you did the build step a long time ago and the     DamlBootPolicyList changed in the mean time. </ul>When building policies, the policyUtil command concatenates the policyprefix with the name of the policy to determine the name for thepolicy .msg file. Thus in DamlBootPolicyList, the policy prefix isdefined by the line <pre> PolicyPrefix=%DamlBootPolicy</pre>and there is a policy defined by<pre> Policy AllowCommunication = [  MessageAuthTemplate    Allow messages from members of $Actor.daml#Agent to    members of $Actor.daml#Agent ]</pre>So after a build there will be a policy fileDamlBootPolicyAllowCommunication.msg that allows all cougaarcommunication. I sometimes use the policy prefix to ensure that thepolicies are written to a different directory. <p>I also have a set of sample policies insecurityservices/test/configs/policies. There are two kinds offiles. The *.policy files are complete policies. If this set ofpolicies replaces the current policies then the system should be ableto continue running. Thus <ul><li> policyUtil commit --dm localhost 8801 RearPolicyDomainManagerServlet AlmostAllow.policy</ul>will set the policies to be a very short and permissive set ofpolicies. AlmostAllow.policy does require encryption on Ultralogmessages though because there can be problems when changing theencryption policy. Allow.policy does not require encryption onUltralog messages. The Allow.policy policy is a littel problematicbecause the transition from using encryption to not using encryptioncan cause some agents to be unable to communicate. <p>I also have policy files of the form *.delta. These policies are not meant to replace the current policies but to modify them. Thus for instance the AllowFwdPolicyServlet.delta is a policy that allows you to log in to the domain manager servlet with a user name of<ul><li> FwdUserDomainComm\george</ul>(and a password of george). If you were to execute the command<ul><li> policyUtil commit --dm localhost 8801 RearPolicyDomainManagerServlet AllowFwdPolicyServlet.delta</ul>then the system would either break or be crippled. There are not enough policies in AllowFwdPolicyServlet.delta to make the system work properly. Instead you can execute the commands:<H1>Configuration Done By CSmart</H1><H2>Flags</H2><p><i>Servlet Access Control</i><p>Servletaccess control is responsible for making decisions about whether a usershould be allowed to access aservlet.  It also controls whichservlet access operations are audited.It uses the following flags:<UL><LI> org.cougaar.core.security.policy.enforcers.servlet.useDaml=true     <ul>     <LI> This flag enables the daml enforcement mechanisms.     </ul><li> org.cougaar.lib.web.tomcat.enableAuth=true     <ul>     <li> Thisflag turns on the authentication mechanisms.     </ul><li> org.cougaar.core.security.audit=true     <ul>     <li> This flag enables audit mechanisms which are also protected          by policy.      </ul></ul><p><i>Message Passing Access Control</i><p>Message passing access control is responsible for controlling ultralogmessaging. There are two types of controls that we currently set:whether the message can be sent or received and how the message shouldbe cryptographically protected. This mechanism uses the followingflags:<ul><li> org.cougaar.core.security.policy.enforcers.crypto.useDaml=true     <ul>     <li> This flag enables the daml enforcement mechanisms for          questions of whether messages should be cryptographically          protected.      </ul><li> org.cougaar.core.security.policy.enforcers.access.useDaml=true      <ul>      <li> This flag enables the daml enforcement mechanisms for           questions of whether messages should be sent or received based           on their content and the sender and the receiver.       </ul></ul><p><i>BlackBoard Access Control</i><p>The Blackboard access control mechanism controls access of plugins tothe blacboard. <ul><li> org.cougaar.core.security.policy.auth.role.useDaml=true     <ul>     <li> This flag controls whether blackboard access control is           turned on.     </ul><li> org.cougaar.core.security.policy.auth.role.useAccessCaching=true     <ul>     <li> This flag causes the enforcement mechanisms to cache the          knowledge that an access to the blackboard is allowed. The          blackboard is heavily accessed during normal operations (much          more so than Ultralog messaging) and it is recommended that this          flag be turned on is blackboard access control is enabled.       </ul><li> org.cougaar.core.security.access.efficientBBS=true     <ul>     <li> When this flag is turned on, blackboard access control is          only utilized for blackboard objects that are subclasses of          SecuredObject.      </ul><p><i>Other</i><ul><li> safe.guard.NodeGuard.createPolicies=false     <ul>     <li> This flag is obsolete and should always be set to false.     </ul></ul><H2>Loaded Components</H2><ul><li> Node.AgentManager.Agent.SecurityComponent(HIGH)=org.cougaar.core.security.policy.webproxy.WebProxySecurityComponent()     <ul>     <li> This component is recommended on every component that hosts          a domain manager. This component intercepts all client web          requests. Those web requests that represent an attempt to obtain          DAML ontologies from the Institute for Machine and Human          Cognition (ihmc) web site are redirected to the configuration          files. There are two reasons why this component is          recommended. First, there are synchronization issues between the          Ultra*Log ontologies and the ontologies on the ihmc web          site. Second, the use of configuration files to supply ontologies          is faster and more self-sufficient.      </ul><li>Node.AgentManager.Agent.SecurityComponent(HIGH)=safe.util.SAFESecurityComponent(EnclaveOnePolicyManager,EnclaveOne)    <ul>    <li> This component should be started on every node. This         component starts the KAoS guard with is responsible for disclosing         answers to policy questions to clients. For example an enforcer         for servlet access might ask if the current policy allows a given         action.     </ul><li>Node.AgentManager.Agent.SecurityComponent(HIGH)=org.cougaar.core.security.provider.SecurityComponentFactory(community)<li> Node.AgentManager.Agent.SecurityComponent(HIGH)=org.cougaar.core.security.crypto.AutoConfigPlugin(eucalyptus:ca1ADAgent)    <ul>    <li> This component is needed to obtain certificates. It is needed         by the message passing and servlet enforcement engines.     </ul><li> Node.AgentManager.Agent.MessageTransport.Aspect(INTERNAL)=org.cougaar.core.security.crypto.MessageProtectionAspectImpl<li> Node.AgentManager.Agent.PluginManager.Binder(BINDER)=org.cougaar.core.security.access.PluginServiceFilter<li> Node.AgentManager.Binder(BINDER)=org.cougaar.core.security.access.AccessAgentBinderFactory<li> plugin =org.cougaar.core.security.policy.enforcers.init.InitAgentPlugin()     <ul>     <li> This component is required on every agent. It ensures that          the domain manager is properly informed about the agent.      </ul><li> plugin = org.cougaar.community.CommunityPlugin     <ul>     <li> This component ensures that the community service works. It          is required on every node. It is needed by the servlet          enforcement mechanisms to find the agents that handle user login          and authentication.      </ul><li> plugin=org.cougaar.core.security.policy.enforcers.init.InitNodePlugin()     <ul>     <li> This component is useful for testing the state of          policies. It tests policies involving communication and servlet          access.      </ul></ul></body>